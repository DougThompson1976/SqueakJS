/* Smalltalk from Squeak4.5 with VMMaker 4.13.6 translated as JS source on 7 October 2014 3:54:26 pm */
/* Automatically generated by
	JSPluginCodeGenerator * VMMakerJS-bf.7 uuid: fe6d3bdb-9095-4ac4-8218-3c47f1fd9805
   from
	BMPReadWriterPlugin VMMaker-bf.351 uuid: af5fd014-b9f4-4d17-80fa-2abd7b2b263b
 */

module("users.bert.SqueakJS.plugins.BMPReadWriterPlugin").requires("users.bert.SqueakJS.vm").toRun(function() {

var VM_PROXY_MAJOR = 1;
var VM_PROXY_MINOR = 11;

/*** Functions ***/
function CLASSOF(obj) { return typeof obj === "number" ? interpreterProxy.classSmallInteger() : obj.sqClass }
function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : 0 }
function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : 0 }
function DIV(a, b) { return Math.floor(a / b) | 0; }   // integer division
function MOD(a, b) { return a - DIV(a, b) * b | 0; }   // signed modulus
function SHL(a, b) { return b > 31 ? 0 : a << b; }     // fix JS shift
function SHR(a, b) { return b > 31 ? 0 : a >>> b; }    // fix JS shift
function SHIFT(a, b) { return b < 0 ? (b < -31 ? 0 : a >>> (0-b) ) : (b > 31 ? 0 : a << b); }

/*** Variables ***/
var interpreterProxy = null;
var moduleName = "BMPReadWriterPlugin 7 October 2014 (e)";



/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

function getModuleName() {
	return moduleName;
}

function halt() {
	;
}

function primitiveRead24BmpLine() {
	var formBits;
	var formBitsIndex;
	var formBitsOop;
	var formBitsSize;
	var pixelLine;
	var pixelLineOop;
	var pixelLineSize;
	var width;

	if ((interpreterProxy.methodArgumentCount()) !== 4) {
		return interpreterProxy.primitiveFail();
	}
	width = interpreterProxy.stackIntegerValue(0);
	if (width <= 0) {
		return interpreterProxy.primitiveFail();
	}
	formBitsIndex = interpreterProxy.stackIntegerValue(1);
	formBitsOop = interpreterProxy.stackObjectValue(2);
	pixelLineOop = interpreterProxy.stackObjectValue(3);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!(formBitsOop.isWords())) {
		return interpreterProxy.primitiveFail();
	}
	if (!(interpreterProxy.isBytes(pixelLineOop))) {
		return interpreterProxy.primitiveFail();
	}
	formBitsSize = SIZEOF(formBitsOop);
	formBits = formBitsOop.words;
	pixelLineSize = SIZEOF(pixelLineOop);
	pixelLine = pixelLineOop.bytes;
	if (!(((formBitsIndex + width) <= formBitsSize) && ((width * 3) <= pixelLineSize))) {
		return interpreterProxy.primitiveFail();
	}
	